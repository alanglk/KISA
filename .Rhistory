Hn <- function(n)
{
# Matriz de centrado (dim. n)
unos <- matrix(rep(1, n), ncol=1)
H <- diag(1, n) - unos%*%t(unos)/n
return(H)
}
HN
CLEAR
n <- 20
p <- 3
set.seed(36209)
X <- matrix(round(runif(n*p, min=10, max=20), digits=1), ncol=p, byrow=TRUE)
X
# Por fila
cf <- X%*%Hn(p)
apply(cf, 1, mean)
View(X)
View(cf)
# Por columna
cc <- Hn(n)%*%X
View(cc)
View(cc)
# Centrar por fila (centrar los datos es restar la media)
cf <- X%*%Hn(p)
apply(cf, 1, mean) # Comprobamos que la media de las columnas es 0
View(cf)
# Centrar por columna
cc <- Hn(n)%*%X
apply(cc, 2, mean) # Comprobamos que la media de las filas es 0
# Centramos por filas y luego por columnas
dc <- Hn(n)%*%X%*%Hn(p)
apply(dc, 1, mean)
apply(dc, 2, mean)
# Dada la matriz A y sus correspondientes vectores de medias por fila (mF ), columna (mC ) y total (mT ),
# comprueba que HAH = HA − mF + mT (en cada caso con las correctas dimensiones).
dc
Hn(n)%*%X - cf + cc
Hn(n)%*%X - cc + cf
# Dada la matriz A y sus correspondientes vectores de medias por fila (mF ), columna (mC ) y total (mT ),
# comprueba que HAH = HA − mF + mT (en cada caso con las correctas dimensiones).
dc
Hn(n)%*%X - cc + cf
Hn(n)%*%X - apply(X, 1, mean) + apply(X, 2, mean)
# Dada la matriz A y sus correspondientes vectores de medias por fila (mF ), columna (mC ) y total (mT ),
# comprueba que HAH = HA − mF + mT (en cada caso con las correctas dimensiones).
dc
Hn(n)%*%X - apply(X, 1, mean) + apply(X, 2, mean)
# Dada la matriz A y sus correspondientes vectores de medias por fila (mF ), columna (mC ) y total (mT ),
# comprueba que HAH = HA − mF + mT (en cada caso con las correctas dimensiones).
A <- matrix(c(1, 2, 3, 4, 3, 1), nrow = 2, ncol = 3)
A
# Dada la matriz A y sus correspondientes vectores de medias por fila (mF ), columna (mC ) y total (mT ),
# comprueba que HAH = HA − mF + mT (en cada caso con las correctas dimensiones).
A <- matrix(c(1, 4, 2, 3, 3, 1), nrow = 2, ncol = 3)
A
hah <- Hn(2)%*%A%*%Hn(3)
hah
apply(A, 1, mean)
apply(A, 2, mean)
apply(hah, 2, mean)
apply(hah, 1, mean)
apply(hah, 2, mean)
ha <-  Hn(2)%*%A
mF <- apply(A, 1, mean)
mf
mF <- apply(A, 1, mean)
mf
apply(A, 1, mean)
bla <- apply(A, 1, mean)
bla
mF <- apply(A, 1, mean)
mF
mC <- apply(A, 2, mean)
hah
ha - mF + mT
ha - mF + mC
mF
mC
mF <- t(apply(A, 1, mean))
mF
mC
ha - mF + mC
mF <- matrix(apply(A, 1, mean), row = 1)
mF <- matrix(apply(A, 1, mean), nrow = 1)
mC <- matrix(apply(A, 2, mean), ncol = 1)
ha - mF + mC
ha
mF
mC
mF <- matrix(apply(A, 1, mean), ncol = 1)
mC <- matrix(apply(A, 2, mean), nrow = 1)
ha
mF
mC
ha -mF
mF <- matrix(apply(A, 1, mean), ncol = 1, nrow = 2, byrow = FALSE)
mF
mF <- matrix(apply(A, 1, mean), ,nrow = 2, ncol = 3, byrow = TRUE)
mF
mF <- matrix(apply(A, 1, mean), ,nrow = 2, ncol = 3, byrow = FALSE)
mF
mF <- matrix(apply(A, 1, mean), nrow = 2, ncol = 3, byrow = FALSE)
mC <- matrix(apply(A, 2, mean), nrow = 2, ncol = 3, byrow = TRUE)
mC
mC <- matrix(apply(A, 2, mean), nrow = 2, ncol = 3, byrow = FALSE)
mC
mC <- matrix(apply(A, 2, mean), nrow = 2, ncol = 3, byrow = TRUE)
ha - mF + mC
hah
apply(A, 1, mean)
mF
apply(A, 2, mean)
mC
ha - mF + mC
mean(A)
mT <- mean(A)
ha - mF + mT
hah == ha - mF + mT
ha - mF + mT
hah
hah == ha - mF + mT
identical(hah, ha - mF + mT)
matequal(hah, ha - mF + mT)
# Comprobar si dos matrices son iguales
matequal <- function(x, y)
is.matrix(x) && is.matrix(y) && dim(x) == dim(y) && all(x == y)
matequal(hah, ha - mF + mT)
# Comprobar si dos matrices son iguales
matequal <- function(x, y){
return is.matrix(x) && is.matrix(y) && dim(x) == dim(y) && all(x == y)
# Comprobar si dos matrices son iguales
matequal <- function(x, y){
return (is.matrix(x) && is.matrix(y) && dim(x) == dim(y) && all(x == y))
}
matequal(hah, ha - mF + mT)
#########################################################################
#                 Distancias, similaridades y kernels                   #
#########################################################################
getwd() #setwd()
dat <- matrix(c(1.1, 2.0
1.9, 0.8
dat <- matrix(c(1.1, 2.0,
1.9, 0.8,
2.4, 2.5,
2.0, 2.9,
5.8, 0.6), byrow = TRUE, ncol = 2)
plot(data, asp = 1)
plot(dat, asp = 1)
dist(dat)
# c)
dist(dat, method = "manhatta")
# c)
dist(dat, method = "manhattan")
# c)
dist(dat, method = "canberra")
# c)
dist(dat, method ="euclidean")
dist(dat, method ="maximum")
dist(dat, method ="manhattan")
dist(dat, method ="canberra")
dist(dat, method ="binary")
dist(dat, method ="minkowski")
dists <- seq(0.1, 1.5, by = 0.02)
dists
# Kernel Matern
Km = exp(dists)
plot(d, y, type = "l")
# Kernel Matern
KM <- function(d){
exp(-d)
}
y <- KM(d)
plot(d, y, type = "l")
########################### Ejercicio 7 #################################
# Vector de distancias entre vectores
dists <- seq(0.1, 1.5, by = 0.02)
# Kernel Matern
KM <- function(d){
exp(-d)
}
y <- KM(d)
plot(d, y, type = "l")
y <- KM(dists)
plot(d, y, type = "l")
plot(dists, y, type = "l")
########################### Ejercicio 7 #################################
# Vector de distancias entre vectores
dists <- seq(0.1, 5, by = 0.05)
# Kernel Matern
KM <- function(d){
exp(-d)
}
y <- KM(dists)
plot(dists, y, type = "l")
plot(dists, y, type = "l", col = "red")
colors()
plot(dists, y, type = "l", col = "lightsalmon")
Km <- KM(dists)
plot(dists, Km, type = "l", col = "lightsalmon")
# Kernel Gausiano desv = 1/2
KG <- function(d){ exp(-d²) }
# Kernel Gausiano desv = 1/2
KG <- function(d){ exp(-d ^2) }
Kg <- KG(dists)
lines(dists, KG(dists))
lines(dists, KG(dists), col = "lightblue")
lines(dists, KM5(dists), col = "purple")
KM2 <- function(d){ exp(-d) } # Kernel Matern 1/2
KG <- function(d){ exp(-d ^2) } # Kernel Gausiano desv = 1/2
KM3 <- function(d){ (1 + sqrt(3) * d) + exp(-sqrt(3) * d) } # Kernel Matern 3/2
KM5 <- function(d){ (1 + sqrt(5) * d + sqrt(5) * d ^ 2 / 3) + exp(-sqrt(5) * d) } # Kernel Matern 5/2
plot(dists, KM2(dists), type = "l", col = "lightsalmon")
lines(dists, KG(dists), col = "lightblue")
lines(dists, KM3(dists), col = "lightgreen")
lines(dists, KM5(dists), col = "purple")
lines(dists, KM3(dists), col = "lightgreen")
plot(dists, KM2(dists), type = "l", col = "lightsalmon")
lines(dists, KM3(dists), col = "lightgreen")
KM3(dists)
KM3 <- function(d){ (1 + sqrt(3) * d) * exp(-sqrt(3) * d) } # Kernel Matern 3/2
KM5 <- function(d){ (1 + sqrt(5) * d * sqrt(5) * d ^ 2 / 3) + exp(-sqrt(5) * d) } # Kernel Matern 5/2
plot(dists, KM2(dists), type = "l", col = "lightsalmon")
lines(dists, KG(dists), col = "lightblue")
lines(dists, KM3(dists), col = "lightgreen")
lines(dists, KM5(dists), col = "purple")
KM5 <- function(d){ (1 + sqrt(5) * d + sqrt(5) * d ^ 2 / 3) * exp(-sqrt(5) * d) } # Kernel Matern 5/2
plot(dists, KM2(dists), type = "l", col = "lightsalmon")
lines(dists, KG(dists), col = "lightblue")
lines(dists, KM3(dists), col = "lightgreen")
lines(dists, KM5(dists), col = "purple")
lines(dists, KG(dists), col = "yellow")
lines(dists, KG(dists), col = "orange")
lines(dists, KM3(dists), col = "lightgreen")
lines(dists, KM5(dists), col = "purple")
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), byrow = TRUE)
matriz
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), 2, byrow = TRUE)
matriz
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), 2, byrow = FALSE)
matriz
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), 2, byrow = TRUE)
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), 2, byrow = TRUE)ç
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), 2, byrow = TRUE)
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), 2, byrow = TRUE)ç
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), 2, byrow = TRUE)
matriz
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), ncol =2, byrow = TRUE)
matriz
matriz[1]
matriz[1:]
plot(matriz])
plot(matriz)
plot(matriz, pch = 23)
plot(matriz, pch = 22)
plot(matriz, pch = 21)
plot(matriz, pch = 21, col = "black")
plot(matriz, pch = 21, col = "black", bg = "black")
plot(matriz, pch = 21, asp = 1, col = "black", bg = "black")
var(matriz)
########################### Ejercicio 1 #################################
x <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), ncol = 2, byrow = TRUE, dimnames =  list(LETTERS[1:4], paste0(("X", 1:2))))
########################### Ejercicio 1 #################################
x <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), ncol = 2, byrow = TRUE, dimnames =  list(LETTERS[1:4], c("X1", "X2")))
x
# Representamos los datos en un plot
plot(x, pch = 21, asp = 1, col = "black", bg = "black")
text(x[, 1], x[, 2], row.names(x))
var(x)
text(x[, 1] + 0.02, x[, 2] + 0.02, row.names(x))
# Representamos los datos en un plot
plot(x, pch = 21, asp = 1, col = "black", bg = "black")
text(x[, 1] + 0.02, x[, 2] + 0.02, row.names(x))
var(x)
eigen(x)
s <- var(x)
eigen(s)
arrows(0, 0, u[1, 1], u[1, 2])
u <- eigen(s)
arrows(0, 0, u[1, 1], u[1, 2])
u
arrows(0, 0, u[, 1])
u[,1]
u
arrows(0, 0, u$vectors[, 1])
arrows(0, 0, u$vectors[, 2])
c1 <- x %*% u$vectors[, 1]
c1
plot(x = c1[,1], y = 0)
plot(x = c1[,1], y = rep(0, length(c1[, 1])))
par(1, 2)
par(mfrow=c(1,2))
# Representamos los datos en un plot
plot(x, pch = 21, asp = 1, col = "black", bg = "black")
text(x[, 1] + 0.02, x[, 2] + 0.02, row.names(x))
s <- var(x)
u <- eigen(s)
c1 <- x %*% u$vectors[, 1]
c1 # vector proyección a una dimensión
plot(x = c1[,1], y = rep(0, length(c1[, 1])))
u
text(x[, 1] + 0.05, x[, 2] + 0.05, row.names(x))
S <- var(x)
u <- eigen(S)
c1 <- x %*% u$vectors[, 1]
c1 # vector proyección a una dimensión
plot(x = c1[,1], y = rep(0, length(c1[, 1])))
########################### Ejercicio 1 #################################
x <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), ncol = 2, byrow = TRUE, dimnames =  list(LETTERS[1:4], c("X1", "X2")))
par(mfrow=c(1,2))
# Representamos los datos en un plot
plot(x, pch = 21, asp = 1, col = "black", bg = "black")
text(x[, 1] + 0.05, x[, 2] + 0.05, row.names(x))
S <- var(x)
u <- eigen(S)
c1 <- x %*% u$vectors[, 1]
c1 # vector proyección a una dimensión
plot(x = c1[,1], y = rep(0, length(c1[, 1])))
text(x = c1[,1], y = rep(0.5, length(c1[, 1])), row.names(x))
text(x = c1[,1], y = rep(0.05, length(c1[, 1])), row.names(x))
text(x = c1[,1], y = rep(0.1, length(c1[, 1])), row.names(x))
########################### Ejercicio 1 #################################
x <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), ncol = 2, byrow = TRUE, dimnames =  list(LETTERS[1:4], c("X1", "X2")))
par(mfrow=c(1,2))
# Representamos los datos en un plot
plot(x, pch = 21, asp = 1, col = "black", bg = "black")
text(x[, 1] + 0.05, x[, 2] + 0.05, row.names(x))
S <- var(x)
u <- eigen(S)
c1 <- x %*% u$vectors[, 1]
c1 # vector proyección a una dimensión
plot(x = c1[,1], y = rep(0, length(c1[, 1])))
plot(x = c2[,1], y = rep(0, length(c2[, 1])))
text(x = c2[,1], y = rep(0.1, length(c2[, 1])), row.names(x))
par(mfrow=c(1,3))
# Representamos los datos en un plot
plot(x, pch = 21, asp = 1, col = "black", bg = "black")
text(x[, 1] + 0.05, x[, 2] + 0.05, row.names(x))
S <- var(x)
u <- eigen(S)
c1 <- x %*% u$vectors[, 1] # vector u_1 proyección a una dimensión
plot(x = c1[,1], y = rep(0, length(c1[, 1])))
text(x = c1[,1], y = rep(0.1, length(c1[, 1])), row.names(x))
c2 <- x %*% u$vectors[, 2] # vector u_1 proyección a una dimensión
plot(x = c2[,1], y = rep(0, length(c2[, 1])))
text(x = c2[,1], y = rep(0.1, length(c2[, 1])), row.names(x))
# Representamos los datos en un plot
plot(x, pch = 21, asp = 1, col = "black", bg = "black", main = "Datos")
plot(x = c1[,1], y = rep(0, length(c1[, 1])), main = "Reducción con U_1")
text(x = c1[,1], y = rep(0.1, length(c1[, 1])), row.names(x))
plot(x = c2[,1], y = rep(0, length(c2[, 1])), main = "Reducción con U_2")
plot(x = c1[,1], y = rep(0, length(c1[, 1])), main = "Reducción con U_1", ylab = "")
########################### Ejercicio 1 #################################
x <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), ncol = 2, byrow = TRUE, dimnames =  list(LETTERS[1:4], c("X1", "X2")))
par(mfrow=c(1,3))
# Representamos los datos en un plot
plot(x, pch = 21, asp = 1, col = "black", bg = "black", main = "Datos")
text(x[, 1] + 0.05, x[, 2] + 0.05, row.names(x))
S <- var(x)
u <- eigen(S)
c1 <- x %*% u$vectors[, 1] # vector u_1 proyección a una dimensión
plot(x = c1[,1], y = rep(0, length(c1[, 1])), main = "Reducción con U_1", ylab = "", xlab = "c1")
text(x = c1[,1], y = rep(0.1, length(c1[, 1])), row.names(x))
c2 <- x %*% u$vectors[, 2] # vector u_1 proyección a una dimensión
plot(x = c2[,1], y = rep(0, length(c2[, 1])), main = "Reducción con U_2", ylab = "", xlab = "c2")
text(x = c2[,1], y = rep(0.1, length(c2[, 1])), row.names(x))
# Nos faltaría centrarlo en torno al 0 (restando la media)
# Nos faltaría centrarlo en torno al 0 (restando la media)
desv <- c(1.580991124, 0.925575205, 0.802349540, 0.003580598)
desv * desv
########################### Ejercicio 2 #################################
X <- read.table("./data/EAD/temperat.csv", header = TRUE, sep = ";")
X
########################### Ejercicio 2 #################################
X <- read.table("./data/EAD/temperat.csv", header = TRUE, sep = ";")
View(X)
View(X)
cor(X)
cor(X, X)
prcomp(X)
prcomp(X)
########################### Ejercicio 2 #################################
X <- read.table("./data/EAD/temperat.csv", header = FALSE, sep = ";")
########################### Ejercicio 2 #################################
X <- read.table("./data/EAD/temperat.csv", header = TRUE, sep = ";")
X
X <- x[!X$Region]
X <- X[!X$Region]
X <- X[, !X$Region]
X <- X[, !(names(X) %in% "Region")]
View(X)
prcomp(X)
cor(X)
# a) Obtener la descomposición de la variabilidad por componentes en términos de porcentaje.
o <- prcomp(X)
o
landa
landa <- o$sdev
landa
vari <- landa / sum(landa) * 100
vari
sum(vari)
vari <- landa / sum(landa) * 100
vari
# Grafico scree
x <- seq(1, length(vari) -1)
x
# Grafico scree
x <- seq(1, length(vari))
plot(x, vari, type = "b", col="seagreen2")
plot(x, vari, type = "b", col="darkorchid3")
descomp_variabilidad <- dataframe(componente = x, landa = landa, variabilidad = vari)
descomp_variabilidad <- data.frame(componente = x, landa = landa, variabilidad = vari)
decomp_variabilidad$var_acum = cumsum(vari)
descomp_variabilidad$var_acum = cumsum(vari)
descomp_variabilidad
X <- X[, !(names(X) %in% c("Moyenne", "Amplitude", "Latitude", "Longitude", "Region"))]
# a) Obtener la descomposición de la variabilidad por componentes en términos de porcentaje.
o <- prcomp(X)
landa <- o$sdev
vari <- landa / sum(landa) * 100
# Grafico scree
x <- seq(1, length(vari))
plot(x, vari, type = "b", col="darkorchid3")
descomp_variabilidad <- data.frame(componente = x, landa = landa, variabilidad = vari)
descomp_variabilidad$var_acum = cumsum(vari)
View(X)
scale(X)
# Grafico scree
x <- seq(1, length(vari))
plot(x, vari, type = "b", col="darkorchid3")
descomp_variabilidad <- data.frame(componente = x, landa = landa, variabilidad = vari)
descomp_variabilidad$var_acum = cumsum(vari)
# b) Interpretar las dos primeras componentes.
cor(o$rotation)
# b) Interpretar las dos primeras componentes.
cor(o$rotation)[, 1]
# b) Interpretar las dos primeras componentes.
cor(o$rotation)[, c(1, 2)]
# b) Interpretar las dos primeras componentes.
cor(o$rotation, X)[, c(1, 2)]
# b) Interpretar las dos primeras componentes.
cor(X, o$rotation)
# b) Interpretar las dos primeras componentes.
cor(X[, 1], o$rotation[, 1])
X
o$rotation
# a) Obtener la descomposición de la variabilidad por componentes en términos de porcentaje.
o <- prcomp(X)
landa <- o$sdev
vari <- landa / sum(landa) * 100
# Grafico scree
x <- seq(1, length(vari))
plot(x, vari, type = "b", col="darkorchid3")
descomp_variabilidad <- data.frame(componente = x, landa = landa, variabilidad = vari)
descomp_variabilidad$var_acum = cumsum(vari)
o$rotation
# b) Interpretar las dos primeras componentes.
cor(X, o$rotation)
o$rotation
X
eigen(X[, 1])
eigen(X)
eigen(var(X))
o$rotation
# b) Interpretar las dos primeras componentes.
cor(var(x), o$rotation)
# b) Interpretar las dos primeras componentes.
cor(var(x), o$rotation)
# b) Interpretar las dos primeras componentes.
cor(var(X), o$rotation)
# b) Interpretar las dos primeras componentes.
cor(X, o$rotation)
cor(var(X), o$rotation)
biplot(X)
o$x
# a) Obtener la descomposición de la variabilidad por componentes en términos de porcentaje.
out <- prcomp(X)
landa <- out$sdev
vari <- landa / sum(landa) * 100
# Grafico scree
x <- seq(1, length(vari))
plot(x, vari, type = "b", col="darkorchid3")
descomp_variabilidad <- data.frame(componente = x, landa = landa, variabilidad = vari)
descomp_variabilidad$var_acum = cumsum(vari)
# b) Interpretar las dos primeras componentes.
eigen(var(X)) # Lo mismo que rotation. Es la matriz de componentes principales C
out$rotation # matriz de autovectores
out$x
cor(var(X), o$rotation)
biplot(X)
biplot(out$x)
biplot(out)
View(out)
View(out)
cor(X, out$x[, 1:2])
out$rotation
cor(X, out$x[, 1:2])
View(X)
View(X)
cor(X, out$x[, 1:2])
cor(X, out$x[, 1:2]) # Correlaciones de Pearson
biplot(out)
