hah
apply(A, 1, mean)
mF
apply(A, 2, mean)
mC
ha - mF + mC
mean(A)
mT <- mean(A)
ha - mF + mT
hah == ha - mF + mT
ha - mF + mT
hah
hah == ha - mF + mT
identical(hah, ha - mF + mT)
matequal(hah, ha - mF + mT)
# Comprobar si dos matrices son iguales
matequal <- function(x, y)
is.matrix(x) && is.matrix(y) && dim(x) == dim(y) && all(x == y)
matequal(hah, ha - mF + mT)
# Comprobar si dos matrices son iguales
matequal <- function(x, y){
return is.matrix(x) && is.matrix(y) && dim(x) == dim(y) && all(x == y)
# Comprobar si dos matrices son iguales
matequal <- function(x, y){
return (is.matrix(x) && is.matrix(y) && dim(x) == dim(y) && all(x == y))
}
matequal(hah, ha - mF + mT)
#########################################################################
#                 Distancias, similaridades y kernels                   #
#########################################################################
getwd() #setwd()
dat <- matrix(c(1.1, 2.0
1.9, 0.8
dat <- matrix(c(1.1, 2.0,
1.9, 0.8,
2.4, 2.5,
2.0, 2.9,
5.8, 0.6), byrow = TRUE, ncol = 2)
plot(data, asp = 1)
plot(dat, asp = 1)
dist(dat)
# c)
dist(dat, method = "manhatta")
# c)
dist(dat, method = "manhattan")
# c)
dist(dat, method = "canberra")
# c)
dist(dat, method ="euclidean")
dist(dat, method ="maximum")
dist(dat, method ="manhattan")
dist(dat, method ="canberra")
dist(dat, method ="binary")
dist(dat, method ="minkowski")
dists <- seq(0.1, 1.5, by = 0.02)
dists
# Kernel Matern
Km = exp(dists)
plot(d, y, type = "l")
# Kernel Matern
KM <- function(d){
exp(-d)
}
y <- KM(d)
plot(d, y, type = "l")
########################### Ejercicio 7 #################################
# Vector de distancias entre vectores
dists <- seq(0.1, 1.5, by = 0.02)
# Kernel Matern
KM <- function(d){
exp(-d)
}
y <- KM(d)
plot(d, y, type = "l")
y <- KM(dists)
plot(d, y, type = "l")
plot(dists, y, type = "l")
########################### Ejercicio 7 #################################
# Vector de distancias entre vectores
dists <- seq(0.1, 5, by = 0.05)
# Kernel Matern
KM <- function(d){
exp(-d)
}
y <- KM(dists)
plot(dists, y, type = "l")
plot(dists, y, type = "l", col = "red")
colors()
plot(dists, y, type = "l", col = "lightsalmon")
Km <- KM(dists)
plot(dists, Km, type = "l", col = "lightsalmon")
# Kernel Gausiano desv = 1/2
KG <- function(d){ exp(-d²) }
# Kernel Gausiano desv = 1/2
KG <- function(d){ exp(-d ^2) }
Kg <- KG(dists)
lines(dists, KG(dists))
lines(dists, KG(dists), col = "lightblue")
lines(dists, KM5(dists), col = "purple")
KM2 <- function(d){ exp(-d) } # Kernel Matern 1/2
KG <- function(d){ exp(-d ^2) } # Kernel Gausiano desv = 1/2
KM3 <- function(d){ (1 + sqrt(3) * d) + exp(-sqrt(3) * d) } # Kernel Matern 3/2
KM5 <- function(d){ (1 + sqrt(5) * d + sqrt(5) * d ^ 2 / 3) + exp(-sqrt(5) * d) } # Kernel Matern 5/2
plot(dists, KM2(dists), type = "l", col = "lightsalmon")
lines(dists, KG(dists), col = "lightblue")
lines(dists, KM3(dists), col = "lightgreen")
lines(dists, KM5(dists), col = "purple")
lines(dists, KM3(dists), col = "lightgreen")
plot(dists, KM2(dists), type = "l", col = "lightsalmon")
lines(dists, KM3(dists), col = "lightgreen")
KM3(dists)
KM3 <- function(d){ (1 + sqrt(3) * d) * exp(-sqrt(3) * d) } # Kernel Matern 3/2
KM5 <- function(d){ (1 + sqrt(5) * d * sqrt(5) * d ^ 2 / 3) + exp(-sqrt(5) * d) } # Kernel Matern 5/2
plot(dists, KM2(dists), type = "l", col = "lightsalmon")
lines(dists, KG(dists), col = "lightblue")
lines(dists, KM3(dists), col = "lightgreen")
lines(dists, KM5(dists), col = "purple")
KM5 <- function(d){ (1 + sqrt(5) * d + sqrt(5) * d ^ 2 / 3) * exp(-sqrt(5) * d) } # Kernel Matern 5/2
plot(dists, KM2(dists), type = "l", col = "lightsalmon")
lines(dists, KG(dists), col = "lightblue")
lines(dists, KM3(dists), col = "lightgreen")
lines(dists, KM5(dists), col = "purple")
lines(dists, KG(dists), col = "yellow")
lines(dists, KG(dists), col = "orange")
lines(dists, KM3(dists), col = "lightgreen")
lines(dists, KM5(dists), col = "purple")
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), byrow = TRUE)
matriz
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), 2, byrow = TRUE)
matriz
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), 2, byrow = FALSE)
matriz
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), 2, byrow = TRUE)
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), 2, byrow = TRUE)ç
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), 2, byrow = TRUE)
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), 2, byrow = TRUE)ç
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), 2, byrow = TRUE)
matriz
########################### Ejercicio 1 #################################
matriz <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), ncol =2, byrow = TRUE)
matriz
matriz[1]
matriz[1:]
plot(matriz])
plot(matriz)
plot(matriz, pch = 23)
plot(matriz, pch = 22)
plot(matriz, pch = 21)
plot(matriz, pch = 21, col = "black")
plot(matriz, pch = 21, col = "black", bg = "black")
plot(matriz, pch = 21, asp = 1, col = "black", bg = "black")
var(matriz)
########################### Ejercicio 1 #################################
x <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), ncol = 2, byrow = TRUE, dimnames =  list(LETTERS[1:4], paste0(("X", 1:2))))
########################### Ejercicio 1 #################################
x <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), ncol = 2, byrow = TRUE, dimnames =  list(LETTERS[1:4], c("X1", "X2")))
x
# Representamos los datos en un plot
plot(x, pch = 21, asp = 1, col = "black", bg = "black")
text(x[, 1], x[, 2], row.names(x))
var(x)
text(x[, 1] + 0.02, x[, 2] + 0.02, row.names(x))
# Representamos los datos en un plot
plot(x, pch = 21, asp = 1, col = "black", bg = "black")
text(x[, 1] + 0.02, x[, 2] + 0.02, row.names(x))
var(x)
eigen(x)
s <- var(x)
eigen(s)
arrows(0, 0, u[1, 1], u[1, 2])
u <- eigen(s)
arrows(0, 0, u[1, 1], u[1, 2])
u
arrows(0, 0, u[, 1])
u[,1]
u
arrows(0, 0, u$vectors[, 1])
arrows(0, 0, u$vectors[, 2])
c1 <- x %*% u$vectors[, 1]
c1
plot(x = c1[,1], y = 0)
plot(x = c1[,1], y = rep(0, length(c1[, 1])))
par(1, 2)
par(mfrow=c(1,2))
# Representamos los datos en un plot
plot(x, pch = 21, asp = 1, col = "black", bg = "black")
text(x[, 1] + 0.02, x[, 2] + 0.02, row.names(x))
s <- var(x)
u <- eigen(s)
c1 <- x %*% u$vectors[, 1]
c1 # vector proyección a una dimensión
plot(x = c1[,1], y = rep(0, length(c1[, 1])))
u
text(x[, 1] + 0.05, x[, 2] + 0.05, row.names(x))
S <- var(x)
u <- eigen(S)
c1 <- x %*% u$vectors[, 1]
c1 # vector proyección a una dimensión
plot(x = c1[,1], y = rep(0, length(c1[, 1])))
########################### Ejercicio 1 #################################
x <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), ncol = 2, byrow = TRUE, dimnames =  list(LETTERS[1:4], c("X1", "X2")))
par(mfrow=c(1,2))
# Representamos los datos en un plot
plot(x, pch = 21, asp = 1, col = "black", bg = "black")
text(x[, 1] + 0.05, x[, 2] + 0.05, row.names(x))
S <- var(x)
u <- eigen(S)
c1 <- x %*% u$vectors[, 1]
c1 # vector proyección a una dimensión
plot(x = c1[,1], y = rep(0, length(c1[, 1])))
text(x = c1[,1], y = rep(0.5, length(c1[, 1])), row.names(x))
text(x = c1[,1], y = rep(0.05, length(c1[, 1])), row.names(x))
text(x = c1[,1], y = rep(0.1, length(c1[, 1])), row.names(x))
########################### Ejercicio 1 #################################
x <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), ncol = 2, byrow = TRUE, dimnames =  list(LETTERS[1:4], c("X1", "X2")))
par(mfrow=c(1,2))
# Representamos los datos en un plot
plot(x, pch = 21, asp = 1, col = "black", bg = "black")
text(x[, 1] + 0.05, x[, 2] + 0.05, row.names(x))
S <- var(x)
u <- eigen(S)
c1 <- x %*% u$vectors[, 1]
c1 # vector proyección a una dimensión
plot(x = c1[,1], y = rep(0, length(c1[, 1])))
plot(x = c2[,1], y = rep(0, length(c2[, 1])))
text(x = c2[,1], y = rep(0.1, length(c2[, 1])), row.names(x))
par(mfrow=c(1,3))
# Representamos los datos en un plot
plot(x, pch = 21, asp = 1, col = "black", bg = "black")
text(x[, 1] + 0.05, x[, 2] + 0.05, row.names(x))
S <- var(x)
u <- eigen(S)
c1 <- x %*% u$vectors[, 1] # vector u_1 proyección a una dimensión
plot(x = c1[,1], y = rep(0, length(c1[, 1])))
text(x = c1[,1], y = rep(0.1, length(c1[, 1])), row.names(x))
c2 <- x %*% u$vectors[, 2] # vector u_1 proyección a una dimensión
plot(x = c2[,1], y = rep(0, length(c2[, 1])))
text(x = c2[,1], y = rep(0.1, length(c2[, 1])), row.names(x))
# Representamos los datos en un plot
plot(x, pch = 21, asp = 1, col = "black", bg = "black", main = "Datos")
plot(x = c1[,1], y = rep(0, length(c1[, 1])), main = "Reducción con U_1")
text(x = c1[,1], y = rep(0.1, length(c1[, 1])), row.names(x))
plot(x = c2[,1], y = rep(0, length(c2[, 1])), main = "Reducción con U_2")
plot(x = c1[,1], y = rep(0, length(c1[, 1])), main = "Reducción con U_1", ylab = "")
########################### Ejercicio 1 #################################
x <- matrix(c(2, 1, 5, 4, 3, 4, 5, 2), ncol = 2, byrow = TRUE, dimnames =  list(LETTERS[1:4], c("X1", "X2")))
par(mfrow=c(1,3))
# Representamos los datos en un plot
plot(x, pch = 21, asp = 1, col = "black", bg = "black", main = "Datos")
text(x[, 1] + 0.05, x[, 2] + 0.05, row.names(x))
S <- var(x)
u <- eigen(S)
c1 <- x %*% u$vectors[, 1] # vector u_1 proyección a una dimensión
plot(x = c1[,1], y = rep(0, length(c1[, 1])), main = "Reducción con U_1", ylab = "", xlab = "c1")
text(x = c1[,1], y = rep(0.1, length(c1[, 1])), row.names(x))
c2 <- x %*% u$vectors[, 2] # vector u_1 proyección a una dimensión
plot(x = c2[,1], y = rep(0, length(c2[, 1])), main = "Reducción con U_2", ylab = "", xlab = "c2")
text(x = c2[,1], y = rep(0.1, length(c2[, 1])), row.names(x))
# Nos faltaría centrarlo en torno al 0 (restando la media)
# Nos faltaría centrarlo en torno al 0 (restando la media)
desv <- c(1.580991124, 0.925575205, 0.802349540, 0.003580598)
desv * desv
########################### Ejercicio 2 #################################
X <- read.table("./data/EAD/temperat.csv", header = TRUE, sep = ";")
X
########################### Ejercicio 2 #################################
X <- read.table("./data/EAD/temperat.csv", header = TRUE, sep = ";")
View(X)
View(X)
cor(X)
cor(X, X)
prcomp(X)
prcomp(X)
########################### Ejercicio 2 #################################
X <- read.table("./data/EAD/temperat.csv", header = FALSE, sep = ";")
########################### Ejercicio 2 #################################
X <- read.table("./data/EAD/temperat.csv", header = TRUE, sep = ";")
X
X <- x[!X$Region]
X <- X[!X$Region]
X <- X[, !X$Region]
X <- X[, !(names(X) %in% "Region")]
View(X)
prcomp(X)
cor(X)
# a) Obtener la descomposición de la variabilidad por componentes en términos de porcentaje.
o <- prcomp(X)
o
landa
landa <- o$sdev
landa
vari <- landa / sum(landa) * 100
vari
sum(vari)
vari <- landa / sum(landa) * 100
vari
# Grafico scree
x <- seq(1, length(vari) -1)
x
# Grafico scree
x <- seq(1, length(vari))
plot(x, vari, type = "b", col="seagreen2")
plot(x, vari, type = "b", col="darkorchid3")
descomp_variabilidad <- dataframe(componente = x, landa = landa, variabilidad = vari)
descomp_variabilidad <- data.frame(componente = x, landa = landa, variabilidad = vari)
decomp_variabilidad$var_acum = cumsum(vari)
descomp_variabilidad$var_acum = cumsum(vari)
descomp_variabilidad
X <- X[, !(names(X) %in% c("Moyenne", "Amplitude", "Latitude", "Longitude", "Region"))]
# a) Obtener la descomposición de la variabilidad por componentes en términos de porcentaje.
o <- prcomp(X)
landa <- o$sdev
vari <- landa / sum(landa) * 100
# Grafico scree
x <- seq(1, length(vari))
plot(x, vari, type = "b", col="darkorchid3")
descomp_variabilidad <- data.frame(componente = x, landa = landa, variabilidad = vari)
descomp_variabilidad$var_acum = cumsum(vari)
View(X)
scale(X)
# Grafico scree
x <- seq(1, length(vari))
plot(x, vari, type = "b", col="darkorchid3")
descomp_variabilidad <- data.frame(componente = x, landa = landa, variabilidad = vari)
descomp_variabilidad$var_acum = cumsum(vari)
# b) Interpretar las dos primeras componentes.
cor(o$rotation)
# b) Interpretar las dos primeras componentes.
cor(o$rotation)[, 1]
# b) Interpretar las dos primeras componentes.
cor(o$rotation)[, c(1, 2)]
# b) Interpretar las dos primeras componentes.
cor(o$rotation, X)[, c(1, 2)]
# b) Interpretar las dos primeras componentes.
cor(X, o$rotation)
# b) Interpretar las dos primeras componentes.
cor(X[, 1], o$rotation[, 1])
X
o$rotation
# a) Obtener la descomposición de la variabilidad por componentes en términos de porcentaje.
o <- prcomp(X)
landa <- o$sdev
vari <- landa / sum(landa) * 100
# Grafico scree
x <- seq(1, length(vari))
plot(x, vari, type = "b", col="darkorchid3")
descomp_variabilidad <- data.frame(componente = x, landa = landa, variabilidad = vari)
descomp_variabilidad$var_acum = cumsum(vari)
o$rotation
# b) Interpretar las dos primeras componentes.
cor(X, o$rotation)
o$rotation
X
eigen(X[, 1])
eigen(X)
eigen(var(X))
o$rotation
# b) Interpretar las dos primeras componentes.
cor(var(x), o$rotation)
# b) Interpretar las dos primeras componentes.
cor(var(x), o$rotation)
# b) Interpretar las dos primeras componentes.
cor(var(X), o$rotation)
# b) Interpretar las dos primeras componentes.
cor(X, o$rotation)
cor(var(X), o$rotation)
biplot(X)
o$x
# a) Obtener la descomposición de la variabilidad por componentes en términos de porcentaje.
out <- prcomp(X)
landa <- out$sdev
vari <- landa / sum(landa) * 100
# Grafico scree
x <- seq(1, length(vari))
plot(x, vari, type = "b", col="darkorchid3")
descomp_variabilidad <- data.frame(componente = x, landa = landa, variabilidad = vari)
descomp_variabilidad$var_acum = cumsum(vari)
# b) Interpretar las dos primeras componentes.
eigen(var(X)) # Lo mismo que rotation. Es la matriz de componentes principales C
out$rotation # matriz de autovectores
out$x
cor(var(X), o$rotation)
biplot(X)
biplot(out$x)
biplot(out)
View(out)
View(out)
cor(X, out$x[, 1:2])
out$rotation
cor(X, out$x[, 1:2])
View(X)
View(X)
cor(X, out$x[, 1:2])
cor(X, out$x[, 1:2]) # Correlaciones de Pearson
biplot(out)
incidences <- matrix(c(0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0), ncol = 3, byrow = TRUE)
View(incidences)
colnames(incidences) <- c("Piedra", "Bronce", "Hierro")
View(incidences)
dist(incidences, method = "Jaccard")
incidences <- matrix(c(0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0), ncol = 3, byrow = TRUE)
colnames(incidences) <- c("Piedra", "Bronce", "Hierro")
dist(incidences, method = "Jaccard")
dist(incidences, method = "binary")
View(incidences)
dists <- 1 - dist(incidences, method = "binary")
dists
dists <- 1 - dist(incidences, by_rows = TRUE, method = "binary")
dists <- 1 - dist(incidences, method = "binary")
cmdscale(dists)
plot(x.mds)
x.mds <- cmdscale(dists)
plot(x.mds)
dists <- sqrt(1 - dist(incidences, method = "binary"))
x.mds <- cmdscale(dists)
plot(x.mds)
# Los objectos se han embebido en una matriz de 4 x 4.
# b) Obt´en una representaci´on eucl´ıdea de estas herramientas e interpreta los resultados.
dists <- dist(incidences, method = "euclidean")
x.mds <- cmdscale(dists)
plot(x.mds)
dists <- sqrt(1 - dist(incidences, method = "binary"))
dists <- sqrt(1 - dist(incidences, method = "binary"))
x.mds1 <- cmdscale(dists)
dists1 <- sqrt(1 - dist(incidences, method = "binary"))
x.mds1 <- cmdscale(dists1)
plot(x.mds, main = "Distancia sqrt(1 - Jaccard)")
# Los objectos se han embebido en una matriz de 4 x 4.
# b) Obt´en una representaci´on eucl´ıdea de estas herramientas e interpreta los resultados.
dists2 <- dist(incidences, method = "euclidean")
x.mds2 <- cmdscale(dists2)
plot(x.mds2, main = "Distancia Euclidea")
dists3 <- 1 - dist(incidences, method = "binary")
# c) Repite el mismo an´alisis considerando pero considerando la distancia entre los
#    objetos i y j como δij = 1 − sij . ¿Cu´al es la dimensi´on en la que se han embebido
#    los objetos?
dists3 <- 1 - dist(incidences, method = "binary")
x.mds3 <- cmdscale(dists3)
plot(x.mds3, main = "Distancia (1 - Jaccard)")
cmdscale(dists1)
# a) Considera la matriz de distancias donde la distancia entre los objetos i y j viene
#    dada como δ2ij = 1 − sij , donde sij es la similaridad de Jaccard. ¿Cuál es la
#    dimensiónn en la que se han embebido los objetos?
dists1 <- sqrt(dist(incidences, method = "binary"))
x.mds1 <- cmdscale(dists1)
plot(x.mds, main = "Distancia sqrt(1 - Jaccard)")
# b) Obtén una representación euclídea de estas herramientas e interpreta los resultados.
dists2 <- dist(incidences, method = "euclidean")
x.mds2 <- cmdscale(dists2)
plot(x.mds2, main = "Distancia Euclidea")
# c) Repite el mismo análisis pero considerando la distancia entre los
#    objetos i y j como δij = 1 − sij . ¿Cuál es la dimensión en la que se han embebido
#    los objetos?
dists3 <- dist(incidences, method = "binary")
x.mds3 <- cmdscale(dists3)
plot(x.mds3, main = "Distancia (1 - Jaccard)")
x.mds1 <- cmdscale(dists1, eig = TRUE)
x.mds1$eig
plot(x.mds1$eig, type="b" )# ¿Cuáles son los valores propios más importantes? similar a un scree graph
x.mds1$points
plot(x.mds, main = "Distancia sqrt(1 - Jaccard)")
# a) Considera la matriz de distancias donde la distancia entre los objetos i y j viene
#    dada como δ2ij = 1 − sij , donde sij es la similaridad de Jaccard. ¿Cuál es la
#    dimensiónn en la que se han embebido los objetos?
dists1 <- sqrt(dist(incidences, method = "binary"))
x.mds1 <- cmdscale(dists1, eig = TRUE)
x.mds1$eig # Valores propios
plot(x.mds1$eig, type="b" ) # ¿Cuáles son los valores propios más importantes? similar a un scree graph
plot(x.mds, main = "Distancia sqrt(1 - Jaccard)")
x.mds1$eig # Valores propios
incidences <- matrix(c(0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0), ncol = 3, byrow = TRUE)
colnames(incidences) <- c("Piedra", "Bronce", "Hierro")
# a) Considera la matriz de distancias donde la distancia entre los objetos i y j viene
#    dada como δ2ij = 1 − sij , donde sij es la similaridad de Jaccard. ¿Cuál es la
#    dimensiónn en la que se han embebido los objetos?
dists1 <- sqrt(dist(incidences, method = "binary"))
x.mds1 <- cmdscale(dists1, eig = TRUE)
x.mds1$eig # Valores propios
plot(x.mds1$eig, type="b" ) # ¿Cuáles son los valores propios más importantes? similar a un scree graph
plot(x.mds, main = "Distancia sqrt(1 - Jaccard)")
plot(x.mds1, main = "Distancia sqrt(1 - Jaccard)")
plot(x.mds1$points, main = "Distancia sqrt(1 - Jaccard)")
x.mds1$GOF
x.mds1$eig # Valores propios
plot(x.mds1$eig, type="b" ) # ¿Cuáles son los valores propios más importantes? similar a un scree graph
plot(x.mds1$points, main = "Distancia sqrt(1 - Jaccard)")
x.mds1$GOF # Goodness Of Fit -> % variabilidad
# b) Obtén una representación euclídea de estas herramientas e interpreta los resultados.
dists2 <- dist(incidences, method = "euclidean")
x.mds2 <- cmdscale(dists2)
plot(x.mds2, main = "Distancia Euclidea")
# c) Repite el mismo análisis pero considerando la distancia entre los
#    objetos i y j como δij = 1 − sij . ¿Cuál es la dimensión en la que se han embebido
#    los objetos?
dists3 <- dist(incidences, method = "binary")
x.mds3 <- cmdscale(dists3)
plot(x.mds3, main = "Distancia (1 - Jaccard)")
plot(x.mds1$points, main = "Distancia sqrt(1 - Jaccard)")
plot(x.mds3, main = "Distancia (1 - Jaccard)")
x.mds3 <- cmdscale(dists3, eig = TRUE)
plot(x.mds3, main = "Distancia (1 - Jaccard)")
plot(x.mds3, main = "Distancia (1 - Jaccard)")
plot(x.mds3$points, main = "Distancia (1 - Jaccard)")
x.mds3$eig
